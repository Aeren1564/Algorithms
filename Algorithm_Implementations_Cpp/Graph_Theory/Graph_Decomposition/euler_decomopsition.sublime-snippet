<snippet>
	<content><![CDATA[
// Decompose the given graph into minimum number of paths and cycles
// O(|V| + |E|)
// Requires graph
template<class T>
void euler_decomopsition(const graph<T> &g, auto process_path, auto process_cycle){
	vector<int> iter(g.n), used((int)g.edge.size());
	for(auto u = 0; u < g.n; ++ u) if(g.ignore) while(iter[u] < g.degree(u) && g.ignore(g.adj[u][iter[u]])) ++ iter[u];
	auto update = [&](int u)->void{
		vector<int> path;
		auto dfs = [&](auto self, int u)->void{
			while(iter[u] < g.degree(u) && (g.ignore && g.ignore(g.adj[u][iter[u]]) || used[g.adj[u][iter[u]]])) ++ iter[u];
			if(iter[u] == g.degree(u)) return;
			int id = g.adj[u][iter[u] ++];
			used[id] = true;
			self(self, g(u, id));
			path.push_back(id);
		};
		dfs(dfs, u);
		assert(!path.empty());
		reverse(path.begin(), path.end());
		int v = u;
		for(auto it: path) v = g(v, it);
		if(u != v) process_path(u, v, path);
		else process_cycle(u, path);
	};
	for(auto u = 0; u < g.n; ++ u){
		int d = g.degree(u) & 1;
		for(auto id: g.adj[u]) if(g.ignore && g.ignore(id) || used[id]) d ^= 1;
		if(!d) continue;
		update(u);
	}
	for(auto u = 0; u < g.n; ++ u){
		while(iter[u] < g.degree(u) && (g.ignore && g.ignore(g.adj[u][iter[u]]) || used[g.adj[u][iter[u]]])) ++ iter[u];
		if(iter[u] == g.degree(u)) continue;
		update(u);
	}
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>euler_decomopsition</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
