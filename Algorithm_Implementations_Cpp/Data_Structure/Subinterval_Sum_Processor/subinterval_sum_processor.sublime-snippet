<snippet>
	<content><![CDATA[
template<class T, class F, class I>
struct subinterval_sum_processor{
#ifdef LOCAL
	#define ASSERT(x) assert(x);
#else
	#define ASSERT(x) 42
#endif
	vector<int> size;
	vector<T> data;
	F TT;
	T T_id;
	I Tinv;
	subinterval_sum_processor(F TT, T T_id, I Tinv): TT(TT), T_id(T_id), Tinv(Tinv){ }
	subinterval_sum_processor &operator=(const subinterval_sum_processor &sum){
		size = sum.size;
		data = sum.data;
		return *this;
	}
	template<class U>
	void build(int n, const vector<U> &a){
		ASSERT((int)a.size() == n);
		size = {n};
		data.assign(n + 1, T_id);
		for(auto i = 0; i < n; ++ i) data[i + 1] = TT(data[i], a[i]);
	}
	template<class U>
	void build(int n, int m, const vector<vector<U>> &a){
		ASSERT((int)a.size() == n);
		for(const auto &b: a) ASSERT((int)b.size() == m);
		size = {n, m};
		data.assign((n + 1) * (m + 1), T_id);
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[(m + 1) * (i + 1) + j + 1] = a[i][j];
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[(m + 1) * (i + 1) + j + 1] = TT(data[(m + 1) * i + j + 1], data[(m + 1) * (i + 1) + j + 1]);
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[(m + 1) * (i + 1) + j + 1] = TT(data[(m + 1) * (i + 1) + j], data[(m + 1) * (i + 1) + j + 1]);
	}
	template<class U>
	void build(int n, int m, int l, const vector<vector<vector<U>>> &a){
		ASSERT((int)a.size() == n);
		for(const auto &b: a){
			ASSERT((int)b.size() == m);
			for(const auto &c: b) ASSERT((int)c.size() == l);
		}
		size = {n, m, l};
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k + 1] = a[i][j][k];
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k + 1] = TT(data[(m + 1) * (l + 1) * i + (l + 1) * (j + 1) + k + 1], data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k + 1]);
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k + 1] = TT(data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * j + k + 1], data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k + 1]);
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k + 1] = TT(data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k], data[(m + 1) * (l + 1) * (i + 1) + (l + 1) * (j + 1) + k + 1]);
	}
	T prefix(int xr) const{
		ASSERT((int)size.size() == 1);
		ASSERT(0 <= xr && xr <= size[0]);
		return data[xr];
	}
	T query(int xl, int xr) const{
		ASSERT((int)size.size() == 1);
		ASSERT(0 <= xl && xl <= xr && xr <= size[0]);
		return TT(Tinv(data[xl]), data[xr]);
	}
	T prefix(int xr, int yr) const{
		ASSERT((int)size.size() == 2);
		ASSERT(0 <= xr && xr <= size[0]);
		ASSERT(0 <= yr && yr <= size[1]);
		return data[(size[1] + 1) * xr + yr];
	}
	T query(int xl, int xr, int yl, int yr) const{
		ASSERT((int)size.size() == 2);
		ASSERT(0 <= xl && xl <= xr && xr <= size[0]);
		return TT(
			TT(
				data[(size[1] + 1) * xl + yl],
				Tinv(data[(size[1] + 1) * xl + yr])
			),
			TT(
				Tinv(data[(size[1] + 1) * xr + yl]),
				data[(size[1] + 1) * xr + yr]
			)
		);
	}
	T prefix(int xr, int yr, int zr) const{
		ASSERT((int)size.size() == 3);
		ASSERT(0 <= xr && xr <= size[0]);
		ASSERT(0 <= yr && yr <= size[1]);
		ASSERT(0 <= zr && zr <= size[2]);
		return data[(size[1] + 1) * (size[2] + 1) * zr + (size[2] + 1) * yr + xr];
	}
#undef ASSERT
};
template<class T, class F = plus<>, class I = negate<>>
auto make_subinterval_sum_processor(F TT = plus<>(), T T_id = T{}, I Tinv = negate<>()){
	return subinterval_sum_processor(TT, T_id, Tinv);
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>subinterval_sum_processor</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
