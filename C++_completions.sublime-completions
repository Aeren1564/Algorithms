{
    "scope":"source.c++",
    "completions":
    [
        { "trigger": "rg", "contents": "ranges::"},

    	{ "trigger": "fori", "contents": "for(auto ${1:i} = ${2:0}; $1 < ${3:n}; ${4:++ $1}){\n\t$0\n}"},
    	{ "trigger": "forqi", "contents": "for(auto ${1:qi} = ${2:0}; $1 < ${3:qn}; ${4:++ $1}){\n\t$0\n}"},
        { "trigger": "rofi", "contents": "for(auto ${1:i} = ${2:n - 1}; $1 >= ${3:0}; ${4:-- $1}){\n\t$0\n}"},
        { "trigger": "forgeneral", "contents": "for($1; $2; $3){\n\t$0\n}"},
    	{ "trigger": "forbitset", "contents": "for(auto ${1:u} = $2._Find_first(); ${1:u} < ${3:n}; ${1:u} = $2._Find_next(${1:u})){\n\t$0\n}"},
        { "trigger": "fordr", "contents": "for(auto [dx, dy]: dr){\n\tint xn = x + dx, yn = y + dy;\n\tif(0 <= min(xn, yn) && xn < nr && yn < nc){\n\t\t$0\n\t}\n}"},
        { "trigger": "trav", "contents": "for(auto $1: $2){\n\t$0\n}"},
        { "trigger": "repeat", "contents": "for(auto rep = ${1:n}; rep; -- rep){\n\t$0\n}"},
    	{ "trigger": "while", "contents": "while($1){\n\t$0\n}"},
        { "trigger": "dowhile", "contents": "do{\n\t$0\n}while($1);"},
    	{ "trigger": "if", "contents": "if($1){\n\t$0\n}"},
    	{ "trigger": "else if", "contents": "else if($1){\n\t$0\n}"},
    	{ "trigger": "else", "contents": "else{\n\t$0\n}"},
    	{ "trigger": "struct", "contents": "struct $1{\n\t$0\n};"},
    	{ "trigger": "return", "contents": "return $1;"},
    	{ "trigger": "exit", "contents": "exit(0);"},
        { "trigger": "decltype", "contents": "decltype($1)"},
        
    	{ "trigger": "sort", "contents": "sort(${1:$2.begin(), $2.end()}$3)"},
    	{ "trigger": "reverse", "contents": "reverse(${1:$2.begin(), $2.end()})"},
        { "trigger": "rotate", "contents": "rotate($1.begin(), $1.begin() + $2, $1.end())"},
    	{ "trigger": "reserve", "contents": "reserve(${1:n})"},
        { "trigger": "accumulate", "contents": "accumulate(${1:$2.begin(), $2.end()}, ${3:0LL}$4)"},
        { "trigger": "partial_sum", "contents": "partial_sum(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "inclusive_scan", "contents": "inclusive_scan(${1:$2.begin(), $2.end()}, $3.begin() + 1, ${4:plus<>()}, ${5:0LL})"},
        { "trigger": "iota", "contents": "iota(${1:$2.begin(), $2.end()}, ${3:0})"},
        { "trigger": "partition", "contents": "partition(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "max_element", "contents": "max_element(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "min_element", "contents": "min_element(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "binary_search", "contents": "binary_search(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "lower_bound", "contents": "lower_bound(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "upper_bound", "contents": "upper_bound(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "equal_range", "contents": "equal_range(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "partition_point", "contents": "partition_point(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "fill", "contents": "fill(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "find", "contents": "find(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "find_if", "contents": "find_if(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "find_if_not", "contents": "find_if_not(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "search", "contents": "search(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()})"},
        { "trigger": "all_of", "contents": "all_of(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "any_of", "contents": "any_of(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "none_of", "contents": "none_of(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "for_each", "contents": "for_each(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "count_", "contents": "count(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "count_if", "contents": "count_if(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "mismatch", "contents": "mismatch(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "shuffle", "contents": "shuffle(${1:$2.begin(), $2.end()}, rng)"},
        { "trigger": "sample", "contents": "sample(${1:$2.begin(), $2.end()}, $3, $4, rng)"},
        { "trigger": "is_sorted", "contents": "is_sorted(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "next_permutation", "contents": "next_permutation(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "prev_permutation", "contents": "prev_permutation(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "set_difference", "contents": "set_difference(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "set_intersection", "contents": "set_intersection(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "set_union", "contents": "set_union(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "set_symmetric_difference", "contents": "set_symmetric_difference(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "includes", "contents": "includes(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "merge", "contents": "merge(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "adjacent_difference", "contents": "adjacent_difference(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "adjacent_find", "contents": "adjacent_find(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "remove", "contents": "$1.erase(remove(${2:$1.begin(), $1.end()}, $3), $1.end());"},
        { "trigger": "remove_if", "contents": "$1.erase(remove_if(${2:$1.begin(), $1.end()}, $3), $1.end());"},
        { "trigger": "copy", "contents": "copy(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "copy_if", "contents": "copy_if(${1:$2.begin(), $2.end()}, $3, $4)"},
        { "trigger": "generate", "contents": "generate(${1:$2.begin(), $2.end()}, rng)"},

        { "trigger": "midpoint", "contents": "midpoint($1, $2)"},
        { "trigger": "lerp", "contents": "lerp($1, $2, $3)"},

        { "trigger": "bind_front", "contents": "bind_front($1, $2)"},

        { "trigger": "rsubrange", "contents": "ranges::subrange($1, $2)"},

        { "trigger": "vempty", "contents": "ranges::empty_view()"},
        { "trigger": "vsingle", "contents": "ranges::single_view($1)"},
        { "trigger": "viota", "contents": "ranges::iota_view($1, $2)"},
        { "trigger": "vistream", "contents": "ranges::istream_view($1)"},

        { "trigger": "vall", "contents": "ranges::views::all($1)"},
        { "trigger": "vfilter", "contents": "ranges::views::filter($1)"},
        { "trigger": "vtransform", "contents": "ranges::views::transform($1)"},
        { "trigger": "vtake", "contents": "ranges::views::take($1)"},
        { "trigger": "vtakewhile", "contents": "ranges::views::take_while($1)"},
        { "trigger": "vdrop", "contents": "ranges::views::drop($1)"},
        { "trigger": "vdropwhile", "contents": "ranges::views::drop_while($1)"},
        { "trigger": "vjoin", "contents": "ranges::views::join"},
        { "trigger": "vlazysplit", "contents": "ranges::views::lazy_split($1)"},
        { "trigger": "vsplit", "contents": "ranges::views::split($1)"},
        { "trigger": "vcounted", "contents": "ranges::views::counted($1)"},
        { "trigger": "vreverse", "contents": "ranges::views::reverse"},
        { "trigger": "velements", "contents": "ranges::views::elements<$1>"},
        { "trigger": "vkeys", "contents": "ranges::views::keys"},
        { "trigger": "vvalues", "contents": "ranges::views::values"},

        { "trigger": "input", "contents": "copy_n(istream_iterator<${1:int}>(cin), ${2:n}, $3.begin())"},
        { "trigger": "output", "contents": "ranges::copy($1, ostream_iterator<${2:int}>(${3:cout}, ${4:\" \"}))"},

        { "trigger": "rall_of", "contents": "ranges::all_of($1, ${2:identity()})"},
        { "trigger": "rany_of", "contents": "ranges::any_of($1, ${2:identity()})"},
        { "trigger": "rnone_of", "contents": "ranges::none_of($1, ${2:identity()})"},
        { "trigger": "rfor_each", "contents": "ranges::for_each($1)"},
        { "trigger": "rfor_each_n", "contents": "ranges::for_each_n($1)"},
        { "trigger": "rcount", "contents": "ranges::count($1)"},
        { "trigger": "rcount_if", "contents": "ranges::count_if($1, ${2:identity()})"},
        { "trigger": "rmismatch", "contents": "ranges::mismatch($1)"},
        { "trigger": "rlexicographical_compare", "contents": "ranges::lexicographical_compare($1)"},
        { "trigger": "rfind", "contents": "ranges::find($1)"},
        { "trigger": "rfind_if", "contents": "ranges::find_if($1)"},
        { "trigger": "rfind_if_not", "contents": "ranges::find_if_not($1)"},
        { "trigger": "rfind_end", "contents": "ranges::find_$1.end()"},
        { "trigger": "rfind_first_of", "contents": "ranges::find_first_of($1)"},
        { "trigger": "radjacent_find", "contents": "ranges::adjacent_find($1)"},
        { "trigger": "rsearch", "contents": "ranges::search($1)"},
        { "trigger": "rsearch_n", "contents": "ranges::search_n($1)"},
        { "trigger": "rcopy", "contents": "ranges::copy($1)"},
        { "trigger": "rcopy_if", "contents": "ranges::copy_if($1)"},
        { "trigger": "rcopy_n", "contents": "ranges::copy_n($1)"},
        { "trigger": "rcopy_backward", "contents": "ranges::copy_backward($1)"},
        { "trigger": "rmove", "contents": "ranges::move($1)"},
        { "trigger": "rmove_backward", "contents": "ranges::move_backward($1)"},
        { "trigger": "rfill", "contents": "ranges::fill($1)"},
        { "trigger": "rfill_n", "contents": "ranges::fill_n($1)"},
        { "trigger": "rtransform", "contents": "ranges::transform($1)"},
        { "trigger": "rgenerate", "contents": "ranges::generate($1, ${2:rng})"},
        { "trigger": "rgenerate_n", "contents": "ranges::generate_n($1, ${2:rng})"},
        { "trigger": "rremove", "contents": "ranges::remove($1, $2)"},
        { "trigger": "rremove_if", "contents": "ranges::remove_if($1, $2)"},
        { "trigger": "rremove_copy", "contents": "ranges::remove_copy($1, $2, $3)"},
        { "trigger": "rremove_copy_if", "contents": "ranges::remove_copy_if($1, $2, $3)"},
        { "trigger": "rreplace", "contents": "ranges::replace($1, $2, $3, $4)"},
        { "trigger": "rreplace_if", "contents": "ranges::replace_if($1, $2, $3, $4)"},
        { "trigger": "rswap_ranges", "contents": "ranges::swap_ranges($1, $2)"},
        { "trigger": "rreverse", "contents": "ranges::reverse($1)"},
        { "trigger": "rreverse_copy", "contents": "ranges::reverse_copy($1, $2)"},
        { "trigger": "rrotate", "contents": "ranges::rotate($1, $2)"},
        { "trigger": "rrotate_copy", "contents": "ranges::rotate($1, $2, $3)"},
        { "trigger": "rshuffle", "contents": "ranges::shuffle($1, ${2:rng})"},
        { "trigger": "rsample", "contents": "ranges::sample($1, $2, $3, ${4:rng})"},
        { "trigger": "ris_partitioned", "contents": "ranges::is_partitioned($1)"},
        { "trigger": "rpartition", "contents": "ranges::partition($1)"},
        { "trigger": "rpartition_copy", "contents": "ranges::partition_copy($1)"},
        { "trigger": "rstable_partition", "contents": "ranges::stable_partition($1)"},
        { "trigger": "rpartition_point", "contents": "ranges::partition_point($1)"},
        { "trigger": "ris_sorted", "contents": "ranges::is_sorted($1)"},
        { "trigger": "ris_sorted_until", "contents": "ranges::is_sorted_until($1)"},
        { "trigger": "rsort", "contents": "ranges::sort($1)"},
        { "trigger": "rpartial_sort", "contents": "ranges::partial_sort($1)"},
        { "trigger": "rpartial_sort_copy", "contents": "ranges::partial_sort_copy($1)"},
        { "trigger": "rstable_sort", "contents": "ranges::stable_sort($1)"},
        { "trigger": "rnth_element", "contents": "ranges::nth_element($1)"},
        { "trigger": "rlower_bound", "contents": "ranges::lower_bound($1)"},
        { "trigger": "rupper_bound", "contents": "ranges::upper_bound($1)"},
        { "trigger": "rbinary_search", "contents": "ranges::binary_search($1)"},
        { "trigger": "requal_range", "contents": "ranges::equal_range($1)"},
        { "trigger": "rmerge", "contents": "ranges::merge($1, $2, $3)"},
        { "trigger": "rinplace_merge", "contents": "ranges::inplace_merge($1, $2)"},
        { "trigger": "rincludes", "contents": "ranges::includes($1, $2)"},
        { "trigger": "rset_difference", "contents": "ranges::set_difference($1, $2, $3)"},
        { "trigger": "rset_intersection", "contents": "ranges::set_intersection($1, $2, $3)"},
        { "trigger": "rset_symmetric_difference", "contents": "ranges::set_symmetric_difference($1, $2, $3)"},
        { "trigger": "rset_union", "contents": "ranges::set_union($1, $2, $3)"},
        { "trigger": "rmax", "contents": "ranges::max($1)"},
        { "trigger": "rmax_element", "contents": "ranges::max_element($1)"},
        { "trigger": "rmin", "contents": "ranges::min($1)"},
        { "trigger": "rmin_element", "contents": "ranges::min_element($1)"},
        { "trigger": "rminmax", "contents": "ranges::minmax($1)"},
        { "trigger": "rminmax_element", "contents": "ranges::minmax_element($1)"},
        { "trigger": "ris_permutation", "contents": "ranges::is_permutation($1)"},
        { "trigger": "rnext_permutation", "contents": "ranges::next_permutation($1).found"},
        { "trigger": "rprev_permutation", "contents": "ranges::prev_permutation($1).found"},

        { "trigger": "inserter", "contents": "inserter($1, $2)"},
        { "trigger": "back_inserter", "contents": "back_inserter($1)"},
        { "trigger": "front_inserter", "contents": "front_inserter($1)"},
        
        { "trigger": "popcount\tCount the number of 1s", "contents": "__builtin_popcount$1($2)"},
        { "trigger": "parity\tGet the parity", "contents": "__builtin_parity$1($2)"},
        { "trigger": "clz\tCount the number of leading zeros", "contents": "__builtin_clz$1($2)"},
        { "trigger": "ctz\tCount the number of trailing zeros", "contents": "__builtin_ctz$1($2)"},
        { "trigger": "ffs\tReturn the position of the first set bit", "contents": "__builtin_ffs$1($2)"},
        { "trigger": "clrsb\tCount the number of leading redundant sign bits", "contents": "__builtin_clrsb$1($2)"},
        { "trigger": "addoverflow", "contents": "__builtin_add_overflow_p($1, $2, ${3:0})"},
        { "trigger": "muloverflow", "contents": "__builtin_mul_overflow_p($1, $2, ${3:0})"},
        { "trigger": "suboverflow", "contents": "__builtin_sub_overflow_p($1, $2, ${3:0})"},
        
        { "trigger": "plus", "contents": "plus<>()"},
        { "trigger": "minus", "contents": "minus<>()"},
        { "trigger": "multiplies", "contents": "multiplies<>()"},
        { "trigger": "devides", "contents": "devides<>()"},
        { "trigger": "modulus", "contents": "modulus<>()"},
        { "trigger": "negate", "contents": "negate<>()"},
        { "trigger": "equal_to", "contents": "equal_to<>()"},
        { "trigger": "not_equal_to", "contents": "not_equal_to<>()"},
        { "trigger": "greater", "contents": "greater<>()"},
        { "trigger": "less", "contents": "less<>()"},
        { "trigger": "greater_equal", "contents": "greater_equal<>()"},
        { "trigger": "less_equal", "contents": "less_equal<>()"},
        { "trigger": "logical_and", "contents": "logical_and<>()"},
        { "trigger": "logical_or", "contents": "logical_or<>()"},
        { "trigger": "logical_not", "contents": "logical_not<>()"},
        { "trigger": "bit_and", "contents": "bit_and<>()"},
        { "trigger": "bit_or", "contents": "bit_and<>()"},
        { "trigger": "bit_xor", "contents": "bit_xor<>()"},
        { "trigger": "bit_not", "contents": "bit_not<>()"},
        { "trigger": "get", "contents": "get<$1>($2)"},

        { "trigger": "ll", "contents": "long long"},
        { "trigger": "ull", "contents": "unsigned long long"},
        { "trigger": "ld", "contents": "long double"},

        { "trigger": "ab", "contents": "array<bool, ${1:2}>"},
        { "trigger": "ai", "contents": "array<int, ${1:2}>"},
        { "trigger": "al", "contents": "array<long long, ${1:2}>"},
        { "trigger": "al", "contents": "array<double, ${1:2}>"},
        { "trigger": "am", "contents": "array<modular, ${1:2}>"},
        { "trigger": "as", "contents": "array<string, ${1:2}>"},
        { "trigger": "aab", "contents": "array<array<bool, ${2:2}>, ${1:2}>"},
        { "trigger": "aai", "contents": "array<array<int, ${2:2}>, ${1:2}>"},
        { "trigger": "aal", "contents": "array<array<long long, ${2:2}>, ${1:2}>"},
        { "trigger": "aad", "contents": "array<array<long long, ${2:2}>, ${1:2}>"},
        { "trigger": "aam", "contents": "array<array<modular, ${2:2}>, ${1:2}>"},
        { "trigger": "aas", "contents": "array<array<string, ${2:2}>, ${1:2}>"},

    	{ "trigger": "pii", "contents": "pair<int, int>"},
        { "trigger": "pil", "contents": "pair<int, long long>"},
        { "trigger": "pli", "contents": "pair<long long, int>"},
        { "trigger": "pll", "contents": "pair<long long, long long>"},

        { "trigger": "vb", "contents": "vector<bool>"},
        { "trigger": "vi", "contents": "vector<int>"},
        { "trigger": "vl", "contents": "vector<long long>"},
        { "trigger": "vd", "contents": "vector<double>"},
        { "trigger": "vm", "contents": "vector<modular>"},
        { "trigger": "vs", "contents": "vector<string>"},

        { "trigger": "vaii", "contents": "vector<array<int, 2>>"},
        { "trigger": "vpii", "contents": "vector<pair<int, int>>"},
        { "trigger": "vpil", "contents": "vector<pair<int, long long>>"},
        { "trigger": "vpli", "contents": "vector<pair<long long, int>>"},
        { "trigger": "val", "contents": "vector<array<long long, 2>>"},
        { "trigger": "vpll", "contents": "vector<pair<long long, long long>>"},
        { "trigger": "vvb", "contents": "vector<vector<bool>>"},
        { "trigger": "vvi", "contents": "vector<vector<int>>"},
        { "trigger": "vvl", "contents": "vector<vector<long long>>"},
        { "trigger": "vvd", "contents": "vector<vector<double>>"},
        { "trigger": "vvm", "contents": "vector<vector<modular>>"},
        { "trigger": "vvai", "contents": "vector<vector<array<int, 2>>>"},
        { "trigger": "vvpii", "contents": "vector<vector<pair<int, int>>>"},
        { "trigger": "vvpil", "contents": "vector<vector<pair<int, long long>>>"},
        { "trigger": "vvpli", "contents": "vector<vector<pair<long long, int>>>"},
        { "trigger": "vval", "contents": "vector<vector<array<long long, 2>>>"},
        { "trigger": "vvpll", "contents": "vector<vector<pair<long long, long long>>>"},
        { "trigger": "vvvi", "contents": "vector<vector<vector<int>>>"},
        { "trigger": "vvvl", "contents": "vector<vector<vector<long long>>>"},
        { "trigger": "vvvd", "contents": "vector<vector<vector<double>>>"},
        { "trigger": "vvvm", "contents": "vector<vector<vector<modular>>>"},
        { "trigger": "vvvai", "contents": "vector<vector<vector<array<int, 2>>>>"},
        { "trigger": "vvvpii", "contents": "vector<vector<vector<pair<int, int>>>>"},
		{ "trigger": "va", "contents": "valarray<${1:int}>"},
        { "trigger": "pq", "contents": "priority_queue<$1>"},
    	{ "trigger": "gpq", "contents": "priority_queue<$1, vector<$1>, greater<>>"},
        { "trigger": "function", "contents": "[&]($1)->${2:void}{\n\t$0\n};"},
        { "trigger": "recursion", "contents": "y_combinator([&](auto self, $1)->${2:void}{\n\t$0\n});"},
        { "trigger": "dfs", "contents": "y_combinator([&](auto self, int u, int _pe)->void{\n\tfor(auto id: g.adj[u] | ranges::views::filter([&](int id){ return !g.ignore || !g.ignore(id);})){\n\t\tif(id == _pe) continue;\n\t\tauto &e = g.edge[id];\n\t\tint v = g(u, id);\n\t\tself(v, id);\n\t\t$0\n\t}\n})(0, -1);"},
        { "trigger": "raw_dfs", "contents": "y_combinator([&](auto self, ${1:int u, int _pv})->${2:void}{\n\tfor(auto v: adj[u]){\n\t\tif(v == _pv) continue;\n\t\t$0self(v, u);\n\t}\n})(${3:0, -1});"},
        { "trigger": "iterate_adj", "contents": "for(auto id: g.adj[u] | ranges::views::filter([&](int id){ return !g.ignore || !g.ignore(id);})){\n\tauto &e = g.edge[id];\n\tint v = g(u, id);\n\t$0\n}"},
        { "trigger": "lambda", "contents": "[&]($1){ $2 }"},
        { "trigger": "unique", "contents": "$1.erase(unique($1.begin(), $1.end()), $1.end())"},
        { "trigger": "runique", "contents": "$1.erase(ranges::unique($1).begin(), $1.end())"},
		
		{ "trigger": "pushb", "contents": "push_back($1)" },
        { "trigger": "pushf", "contents": "push_front($1)" },
    	{ "trigger": "popb", "contents": "pop_back()"},
        { "trigger": "popf", "contents": "pop_front()"},
        { "trigger": "emplaceb", "contents": "emplace_back($1)" },
    	{ "trigger": "front", "contents": "front()"},
    	{ "trigger": "back", "contents": "back()"},
    	{ "trigger": "begin", "contents": "begin()"},
    	{ "trigger": "end", "contents": "end()"},
    	{ "trigger": "rbegin", "contents": "rbegin()"},
    	{ "trigger": "rend", "contents": "rend()"},
    	{ "trigger": "insert", "contents": "insert($1)"},
    	{ "trigger": "erase", "contents": "erase($1, $2)"},
        { "trigger": "erase_if", "contents": "erase_if($1, $2)"},
    	{ "trigger": "first", "contents": "first"},
    	{ "trigger": "second", "contents": "second"},
        { "trigger": "find_by_order", "contents": "find_by_order($1)"},
        { "trigger": "order_of_key", "contents": "order_of_key($1)"},
        { "trigger": "_Find_first", "contents": "_Find_first()"},
        { "trigger": "_Find_next", "contents": "_Find_next($1)"},

    	{ "trigger": "precision", "contents": "cout << fixed << setprecision(15);"},
        { "trigger": "mod1", "contents": "1e9 + 7"},
        { "trigger": "mod2", "contents": "(119 << 23) + 1"},
        { "trigger": "limit", "contents": "numeric_limits<${1:long long}>::${2:max}()"},
        { "trigger": "all", "contents": "$1.begin(), $1.end()"},
        { "trigger": "rall", "contents": "$1.rbegin(), $1.rend()"},
        { "trigger": "sz", "contents": "(int)$1.size()"},
        { "trigger": "pi", "contents": "const double pi = acos(-1);"},
        { "trigger": "kill", "contents": "auto kill = [](){\n\t${1:cout << -1;}\n\texit(0);\n};"},
        { "trigger": "iop", "contents": "istream &operator>>(istream &in, $1 &$2){\n\t${3:return in >> $2;}\n}"},
        { "trigger": "oop", "contents": "ostream &operator<<(ostream &out, const $1 &$2){\n\t${3:return out << $2;}\n}"},
        { "trigger": "floored_division", "contents": "template<class T>\nT floored_division(T x, T y){\n\treturn x / y - ((x ^ y) < 0 && x % y);\n}"},
        { "trigger": "cl", "contents": "cout << \"\\n\";"},
        { "trigger": "flush", "contents": "cout << endl;"},
        { "trigger": "order_statistic_trees", "contents": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<class T, class U, class Compare = less<>> using order_statistic_map = tree<T, U, Compare, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<class T, class Compare = less<>> using order_statistic_set = order_statistic_map<T, null_type, Compare>;"},
        { "trigger": "changeto", "contents": "template<class T> T &ctmin(T &x){ return x; }\ntemplate<class T, class Head, class ...Tail> T &ctmin(T &x, const Head &h, const Tail &... t){ return ctmin(x = min<T>(x, h), t...); }\ntemplate<class T> T &ctmax(T &x){ return x; }\ntemplate<class T, class Head, class ...Tail> T &ctmax(T &x, const Head &h, const Tail &... t){ return ctmax(x = max<T>(x, h), t...); }\n"},
        { "trigger": "inrange", "contents": "auto in_range = [&](int ${1:x}, int ${2:y}){ return ${3:0 <= $1 && $1 < ${4:nr} && 0 <= $2 && $2 < ${5:nc}}; };"},
        { "trigger": "index", "contents": "auto index = [&](int ${1:x}, int ${2:y}){ return ${3:nc} * $1 + $2; };"},
        
        { "trigger": "fopen", "contents" : "ifstream cin; ofstream cout;\ncin.open(\"$1.in\"); cout.open(\"$1.out\");"},
        { "trigger": "fclose", "contents": "cin.close(); cout.close();"},
        { "trigger": "initialize", "contents": "	cin.tie(0)->sync_with_stdio(0), cin.exceptions(ios::badbit | ios::failbit);"},
        { "trigger": "local", "contents": "#ifdef LOCAL\n$0\n#else\n\n#endif"},
        { "trigger": "mt19937", "contents": "mt19937(chrono::high_resolution_clock().now().time_since_epoch().count())"},
        { "trigger": "mt19937_64", "contents": "mt19937_64(chrono::high_resolution_clock().now().time_since_epoch().count())"},
        { "trigger": "pragma", "contents": "#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx2,popcnt,lzcnt,abm,bmi,bmi2\")\n// #pragma GCC target(\"sse,sse2,sse3,sse4,sse4.1,sse4.2,tune=native,popcnt,lzcnt,abm,bmi,bmi2\")"},
        { "trigger": "json", "contents": "#include \"json.hpp\"\nusing json = nlohmann::json;"},
    ]
}